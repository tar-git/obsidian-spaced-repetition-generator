/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SpacedRepetitionGenerator
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// abstract_transformer.ts
var AbstractTransformer = class {
  constructor(content) {
    this.outputContent = "";
    this.prev = null;
    this.current = null;
    this.next = null;
    this.alreadyHasFlashTag = false;
    this.flashCardSymbol = "\u{1F0CF}";
    this.flashCardSeparator = "\u2014";
    this.inputContent = content;
    this.inputLines = content.split("\n");
    if (this.inputLines.length > 2) {
      this.prev = this.inputLines[0];
      this.current = this.inputLines[1];
      this.next = this.inputLines[2];
    }
    if (this.prev == "---") {
      this.state = 1 /* InsideProps */;
    }
  }
  transform() {
    if (this.prev == null || this.current == null || this.next == null) {
      return this.inputContent;
    }
    this.outputContent += this.prev + "\n";
    let idx = 1;
    while (idx < this.inputLines.length) {
      this.setState();
      let newLine = this.processLine();
      if (newLine != null) {
        this.outputContent += newLine + "\n";
      }
      this.prev = this.inputLines[idx];
      this.current = this.next;
      if (idx + 2 < this.inputLines.length) {
        this.next = this.inputLines[idx + 2];
      } else {
        this.next = null;
      }
      idx++;
    }
    return this.outputContent;
  }
  processLine() {
    switch (this.state) {
      case 1 /* InsideProps */:
        return this.processPropLine();
      case 2 /* InsideTags */:
        return this.processTagLine();
      case 4 /* Heading */:
        return this.processHeadingLine();
      case 5 /* Empty */:
        return this.processEmptyLine();
      case 3 /* InsideSnippet */:
        return this.processSnippet();
      default:
        return this.processRegular();
    }
  }
  processHeadingLine() {
    if ((!this.isSeparator(this.prev) || this.prevState == 1 /* InsideProps */) && !this.isEmpty(this.prev)) {
      this.current = "\n" + this.current;
    }
    return this.current;
  }
  processPropLine() {
    if (this.current == "---") {
      this.prevState = 1 /* InsideProps */;
      this.state = 0 /* None */;
    }
    if (this.current == "tags:") {
      this.state = 2 /* InsideTags */;
    }
    return this.current;
  }
  setState() {
    if ([1 /* InsideProps */, 2 /* InsideTags */, 3 /* InsideSnippet */].includes(this.state)) {
      return;
    }
    if (this.prevState != 1 /* InsideProps */) {
      this.prevState = this.state;
    }
    if (this.isHeading(this.current)) {
      this.state = 4 /* Heading */;
    } else if (this.isEmpty(this.current)) {
      this.state = 5 /* Empty */;
    } else {
      this.state = 0 /* None */;
    }
  }
  hasFlashTag(line) {
    return line.indexOf(this.flashCardSymbol) != -1;
  }
  isHeading(line) {
    let regex = /^#+ .+?/;
    return regex.test(line);
  }
  isSeparator(line) {
    let regex = /^(___+|---+)/;
    return regex.test(line);
  }
  isFlashCardSeparator(line) {
    return line.indexOf(this.flashCardSeparator) >= 0;
  }
  isEmpty(line) {
    let regex = /^\s*$/;
    return regex.test(line);
  }
  isTag(line) {
    let regex = /^ +- \S+/;
    return regex.test(line);
  }
  isSnippetStart(line) {
    let regex = /^```+\S+$/;
    return regex.test(line);
  }
  isSnippetEnd(line) {
    let regex = /^```$/;
    return regex.test(line);
  }
};

// flashcard_transformer.ts
var FlashcardTransformer = class extends AbstractTransformer {
  processHeadingLine() {
    this.current = super.processHeadingLine();
    if (this.next != this.flashCardSeparator) {
      this.current = this.current + "\n" + this.flashCardSeparator;
    }
    return this.current;
  }
  processRegular() {
    if (this.isSnippetStart(this.current)) {
      this.state = 3 /* InsideSnippet */;
    }
    return this.current;
  }
  processEmptyLine() {
    if (this.next == null || this.isHeading(this.next) || this.isSeparator(this.next)) {
      if (this.outputContent.slice(-5, -1) == "<br>") {
        let lastChar = this.next == null ? "" : "\n";
        this.outputContent = this.outputContent.slice(0, -5) + lastChar;
      }
      return "";
    }
    if (this.isFlashCardSeparator(this.outputContent.slice(-2, -1))) {
      return null;
    }
    if (this.state == 3 /* InsideSnippet */) {
      return this.current;
    }
    return "<br>";
  }
  processTagLine() {
    if (this.current == "---") {
      this.prevState = 1 /* InsideProps */;
      this.state = 0 /* None */;
      if (!this.alreadyHasFlashTag) {
        return "  - " + this.flashCardSymbol + "\n---";
      }
      return this.current;
    }
    if (this.isTag(this.current)) {
      this.alreadyHasFlashTag = this.alreadyHasFlashTag || this.hasFlashTag(this.current);
      return this.current;
    } else {
      this.state = 1 /* InsideProps */;
      if (!this.alreadyHasFlashTag) {
        return "  - " + this.flashCardSymbol + "\n" + this.current;
      }
      return this.current;
    }
  }
  processSnippet() {
    if (this.isSnippetEnd(this.current)) {
      this.state = 0 /* None */;
    }
    return this.current;
  }
};

// note_transformer.ts
var NoteTransformer = class extends AbstractTransformer {
  processHeadingLine() {
    if (!this.isEmpty(this.next) || this.next.includes("\u2014")) {
      this.next = "";
    }
    return super.processHeadingLine();
  }
  processRegular() {
    if (String(this.current).includes("<br>")) {
      return this.current.replace(/<br>/g, "") + "\n";
    }
    return this.current;
  }
  processEmptyLine() {
    return this.current;
  }
  processTagLine() {
    if (this.current == "---") {
      this.prevState = 1 /* InsideProps */;
      this.state = 0 /* None */;
      return this.current;
    }
    if (this.isTag(this.current)) {
      if (this.hasFlashTag(this.current)) {
        this.outputContent = this.outputContent.slice(0, -1);
        return "";
      }
    } else {
      this.state = 1 /* InsideProps */;
    }
    return this.current;
  }
  processSnippet() {
    return null;
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var SpacedRepetitionGenerator = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    let transformToFlashCommand = () => {
      let view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if ((view == null ? void 0 : view.data) == null) {
        return;
      }
      const transformer = new FlashcardTransformer(view.data);
      const newContent = transformer.transform();
      view.setViewData(newContent, false);
    };
    let transformToNoteCommand = () => {
      let view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if ((view == null ? void 0 : view.data) == null) {
        return;
      }
      const transformer = new NoteTransformer(view.data);
      const newContent = transformer.transform();
      view.setViewData(newContent, false);
    };
    this.addRibbonIcon("dice", "transform", transformToFlashCommand);
    this.addCommand({
      id: "transform-to-flashcards",
      name: "Transform note to flashcards",
      callback: transformToFlashCommand
    });
    this.addCommand({
      id: "transform-to-notes",
      name: "Transform flashcards to note",
      callback: transformToNoteCommand
    });
    const statusBarItemEl = this.addStatusBarItem();
    statusBarItemEl.setText("Status Bar Text");
    this.addCommand({
      id: "open-sample-modal-simple",
      name: "Open sample modal (simple)",
      callback: () => {
        new SampleModal(this.app).open();
      }
    });
    this.addCommand({
      id: "sample-editor-command",
      name: "Sample editor command",
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        editor.replaceSelection("Sample Editor Command");
      }
    });
    this.addCommand({
      id: "open-sample-modal-complex",
      name: "Open sample modal (complex)",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (markdownView) {
          if (!checking) {
            new SampleModal(this.app).open();
          }
          return true;
        }
      }
    });
    this.addSettingTab(new SampleSettingTab(this.app, this));
    this.registerDomEvent(document, "click", (evt) => {
      console.log("click", evt);
    });
    this.registerInterval(window.setInterval(() => console.log("setInterval"), 5 * 60 * 1e3));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SampleModal = class extends import_obsidian.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText("Woah!");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Setting #1").setDesc("It's a secret").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.mySetting).onChange(async (value) => {
      this.plugin.settings.mySetting = value;
      await this.plugin.saveSettings();
    }));
  }
};
